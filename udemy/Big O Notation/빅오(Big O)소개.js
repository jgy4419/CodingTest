/*
    1. 빅오표기법 필요성
    2. 왜 중요한지?
    3. 빅오 표기법을 간단하게 표현하는 방법
    4. "시간 복잡성"과 "공간 복잡성"을 정의
    5. 빅오 표기법을 사용해 여러가지 랄고리즘 평기
    6. 로그가 무엇인지?
*/

/* 
    1. 빅오표기법 필요성
    - 빅오표기법 : 여러가지 코드를 일반적으로 서로 벼교하고 성능을 평가하는 방법.
    즉, "좋은", "그저그런" 또는 "엉망인" 코드라고 말하는 대신 숫자로 코드의 성능을 표기.
*/

/* 
    2. 왜 중요한지?
    - 코드의 성능을 얘기할 때 정확한 전문용어를 사용하는 것이 중요하다. 우리가 만든 해결책이 만족스럽다고
    생각해도 다른 해결책과 비교하고, 성능이 어떤지 이해하는 것이 도움이 된다.
    - 여러 접근법의 장단점을 얘기할때도 유용하다. 가장 좋은 해결책을 찾는 것이 그렇게 뻔하지 않기 때문이다.
    한 해결책에 정말 좋고 또 하나는 엉망인 경우가 많지는 않다.(해결책이 많은 데이터랑 다루는 것을 잘 할 수 있다.)
    - 코드를 디버그할때 코드를 느리게 만드는 것을 상대방에게 이해시키는 것이 중요하다. : 에러만을 찾는 것이 아니라, 코드가 작동을 하지만
    생각보다 더 오랜 시간이 걸리거나, 브라우저에서 함수를 실행했을 때 컴퓨터가 렉걸린다 생각해보자. ㅋㅋ
    - 면접에서 자주 나온다 : 질문중에 "이 알고리즘의 빅오 표기법을 말해주세요." 또는 "여기 함수 3개가 있는데 빅오가 무엇인가요?" 라는 질문 등
    면접에서도 자주 나오므로 중요하다.

    > 정리해보면 우리가 쓰는 코드를 더 잘 이해하고 더 좋은 코드를 쓰기 위해 도움이 된다. (+ 면접)
*/

// 3. 빅오 표기법을 간단하게 표현하는 방법
// 조금 더 구체적으로 같은 문제를 해결하는 해결법 비교해보기.
// ex) 1에서부터 특정한 N 값과 사이에 있는 모든 숫자들을 더하는 함수 만들기. => 3이 인자로 들어가면 1 + 2 + 3 해서 결과는 6이 나온다.
function solution3_1(n) {
    let total = 0;
    for (let i = 1; i <= n; i++){
        total += 1;
    }
    return total;
}

function solution3_2(n) {
    return n * (n + 1) / 2;
}
/*
    위 코드에서 더 나은코드는?
    1) 더 빠르고
    2) 메모리 차지랑
    3) 코드를 얼마나 쉽게 읽을 수 있는지?)
    사람들은 프로그래밍을 할 때 최대한 적은 코드를 쓰는 것을 좋아한다. 하지만 3번째 말고 1, 2번째를 더 중요시 여긴다.(3번도 좋으면.. 더 좋고..)

    * 1), 2)를 평가하는 방법
   - 내장 되어 있는 타이밍 함수를 사용하는 것이다.
   - performance.now() : 브라우저가 해당 문저를 만든 시간, 창이 열린 시간을 알려준다.
*/

let t1 = performance.now();
solution3_1(100000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
// 이렇게 수동으로 타이밍을 구하고 서로 비교 하는 것이 가장 좋은 방법은 아니다.
/* 
    - 측정하는 방법.
    1) 해당 기기에 무엇이 실행 되고 있는지에 따라 다를 수도 있고, 
    2) 똑같은 기계와 다른 시간을 기록할 수도 있다.
    3) 빠른 알고리즘에서는 정말 짧은 시간 안에 모든 것이 처리 된다는 것. 이런 경우는 속도 측정 정확도가
    충분하지 않을 수 있다.

    그래도 불구하고 코드를 보면서 시간을 측정 하지 않고 어느 코드가 더 좋은지 평가하는지.
*/

/* 
    6강 : 연산 갯수 세기 
    코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것 보다는 대신에 컴퓨터가 처리해야하는 연산 개수를 세면 된다.
    그 이유는 어떤 컴퓨터를 사용하든 그 개수는 변하지 않기 때문 
*/

/* 
    7강 : 시간복잡도 시각화하기

*/

/* 
    8강 : 빅오에 대한 정식 소개
    빅오 
    - 대략적으로 숫자를 세는 것에 븥인 정식적인 표현이다.
    - 정식적으로 입력된 내용이 늘어날 수록 알고리즘에 실행 시간이 어떻게 변하는지 설명하는 공식적인 방법.
    - 빅오는 어떤 함수의 입력 값이 늘어나는 것과 함수 실행 시간이 변하는 관계를 의미한다.
    - 입력의 크기와 실행시간의 관계를 말한다.
    
    Big O Definition (빅오정의)
    - N이 커질 수록 컴퓨터가 f(n) 상수 곱하기 f(n)보다 간단한 연산을 덜 해야된다면 그 알고리즘을
      O(f(n))이라고 표현한다. 
    - f(n) = n => 선형이다 즉, N 값이 커질수록 실행 시간도 같이 늘어난다.
    - f(n) = n2(제곱) => 실행시간이 N의 제곱
    - f(n) = 1 => N이 커져도 실행 시간에 아무 영향도 받지 않기 때문에 항상 상수이다. (1이라고 표현.)

    빅오를 얘기했을때는 실행시간이 갖을 수 있는 최대치이다. 일반적으로 가장 높은 실행 시간 값들을 말한느 것.
*/

// ex) O(1)
function addUpTo(n) {
    // 언제나 항상 연산이 3개이므로 상수이다.
    return n * (n + 1) / 2;
}

// ex) O(n)
function addUpTo(n){
    // n이 커질수록 실행 시간이 1:1 비율로 늘어나고, 연산의 개수는 궁극적으로 N의 곱과 연결되어 있다.
    let total = 0;
    for(let i = 1; i <= n; i++) {
        total += i;
    }
    return total;
}

/* 
    O(n) 규칙
    - 기본적으로 신경 쓰는 것은 자릿수. 그렇게 때문에 5n이든 n이든 상관 x.
    - 시각적으로 표현해보면 별 차이가 없다는 것이다. (대략적으로 같다.)
    - 
*/

// 아래 코드에서 빅오를 찾아보기
function countUpAndDown(n) {
    console.log('Going up!');
    // 인자 n이 늘어날 수록 루프 안에서 연산이 늘어난다. 그래서 for i랑, j의 반복문은 O(n)이다.
    for(let i = 0; i < n; i++){
        console.log(i);
    }
    console.log('At the top! \n Going down...');
    for(let j = n - 1; j >= 0; j--){
        console.log(j);
    }
    console.log('Back down. Bye!');
}
// i 작업(n)을 하고 j작업(n)을 하므로 빅오가 2n이라고 생각할 수 있는데, 아니다. 큰 그림만 신경써야된다. 그러므로 O(n)이다.

// 다음예제
function printAllPairs(n) {
    // O(n)
    for(let i = 0; i < n; i++){
        // O(n)
        for(let j = 0; j < n; j++){
            console.log(i, j);
        }
    }
}

// 위의 코드는 O(n)이 2개라 O(2n)이 되지 않고, 중첩(O(n)안에 O(n))되어 있기 때문에 O(n제곱)이 된다.
// 즉, n이 커질수록 실행시간이 n제곱의 값으로 늘어난다는 것이다.

/* 
    9강 : 빅오표기법 단순화하기
    
    빅오표현의 식들을 쉽게 단순화하기 위해 도움이 될 규칙들에 대해 알아보기
    1) 가장 중요하게 생각하는 것은 <대략적으로 정확한 큰 그림>. 그렇기 때문에 상수는 중요하지 않다.
    2) O(500)이 있으면 O(1)이라고 한다. 왜냐면 O(500)은 연산 개수가 어떤 상황에든 500개가 있다는 것이다.
       n이 무엇이든 그래프에 선은 납작할 것이다. (위로 올라가지 않음.)
    3) 2)처럼 상수를 없애버리면 단순화된 것들(O(1), O(n), O(n제곱))로만 비교할 수 있다. 그러면 바로 O(1)이 O(n)보다
       빠르고 O(n제곱)이 가장 느리다는 것들도 알 수 있다.

    ex1) O(n + 10) x => O(n) o
    ex2) O(1000n + 50) x => O(n) o
    ex3) O(n제곱 + 5n + 8) x => O(n제곱)

    명심해야 되는 몇가지는 빅오의 복잡도를 분석할 때, 매우 복잡해진다. 섬세하게 작은 내용들까지 따질 수도 있지만
    쉽게 적용할 수 있는 규칙이 있다. (항상 맞지는 않지만 좋은 시작점이 된다.)
    1) 산수는 상수라는 것이다. 덧셈, 뺄셈, 곱셈, 나눗셈을 포함한다. (n의 값이 상관없다.)
       컴퓨터가 2+2를 처리하는 시간과 100만 + 2를 처리하는 시간은 비슷하다.
    2) 변수 배정도 상수이다 : x = 1000를 처리하는것과 x = 20000을 하든 100만을 처리하는것은 비슷한 시간이 걸린다. 
       인덱스를 사용해서 배열 엘리먼트를 접근하는 것.
    3) 배열에서 첫번째 아이템을 찾던지, 10번째 아이템을 찾던지 인덱스를 사용하면 똑같은 시간이 걸린다. 아니면 객체를 다루고 
        데이터를 접근하기 위해서 키가 있다면 그것도 실행 시간이 상수이다.
    4) 다음 규칙은 루프가 있으면 복잡도가 루프의 길이 곱하기 루프안에 있는 연산이다. 그렇기 때문에 리스트에 있는 데이터를 루프로 처리 시
    0에서 n까지 간다면, n이 커질 수록 루프가 반복되는 횟수가 늘어난다. 그렇다면 루프안에서 일어나는 작업들도 중요할 수 있다. 만약 중첩
    루프가 있으면 n제곱 실행 시간이 될 수 있다.

    위의 1) ~ 4)를 다 외울 필요는 없지만 알고 있으면 좋다.
*/

// ex1) 
function logAtLeast(n) {
    /* 
        n이 1~5가 입력되면 5번, 5보다 큰 값(6, 7, 8, 9, 10 ...)을 입력하면 큰 값 기준으로 반복문을 돌린다.
        이런 경우 시간 복잡도는?
        5를 신경쓸 수 있지만. n이 작을 경우에만 중요한 부분이다.
        주목해야될 경우는 n이 더 커지는 경우이다. 그렇게만 따지면 O(n)라고 단순화해서 말할 수 있다. 왜냐하면
        n이 커질수록 연산 개수가 n에 비례해서 늘어나기 때문이다.
    */
    for(var i = 0; i <= Math.max(5, n); i++) {
        console.log(i);
    }
}

// ex2) ex1과 반대인 경우. (n이 아무리 커져도 아무 영향을 주지 않는다는 것.)
function logAtMost(n){
    // n에 어떤 값을 넣어도 5를 넘지 않을 것이다. 그렇기 때문에 n이 커질수록 빅오는 상수라고 단순화할 수 있다.
    // 그래서 O(5)라고 쓰는 대신 O(1)이라고 단순화할 수 있는 것이다.
    for(let i = 0; i <= Math.min(5, n); i++) {
        console.log(i);
    }
}
// 앞으로 어떤 알고리즘을 쓰고 그 알고리즘의 실행시간이 O(n제곱)으로 표현할 수 있다고 말하면 그것이 O(n)보다는
// 더 안좋다는 것을 분별할 수 있을 것이다.

/* 
    10강 : 공간복잡도
    지금까지 시간과 관련되어 있었다. 알고리즘들이 얼마나 빠르게 실행하는지? 이것을 시간 복잡도라고 한다.
    입력이 커질수록 알고리즘의 실행 속도가 어떻게 바뀌는지 분석했다. 
    이제는 입력이 커질수록 얼마나 많은 공간을 차지 하는지에 대해 얘기해보자. 
    빅오 표기법을 사용할 수 있지만 일어나는 현상을 표현하기 위해서 같은 방식으로 표기할 수 있지만 이제는
    공간, 사용되는 메모리를 주목하자.
    - 기본적인 내용들
    1) 당연한 것이지만 n이 커질수록, 무한대까지 가면서 입력 자체가 커진다는 것이다.
    2) 보조 공간 복잡도 : 입력 되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간을 의미한다. (중요)

    - 몇 가지 규칙들
    1) boolean, 숫자, undefined, null은 자바스크립트에서 모두 불변 공간이다. 그렇기 때문에 입력의 크기와는 상관없이
    숫자가 1이든 1000이든, boolean이 참이든 거짓이든 모두 불변 공간이라 여긴다.
    2) 문자열을 O(n) 공간이 필요하다. ex) n의 문자열의 길이라면, 50자인 입력이 있다면 그 문자열은 길이가 1인 문자열보다
    50배 더 많은 공간을 차지하게 될 것이다.
    3) reference 타입, 배열과 객체도 대부분 O(n) 이라고 생각한다. n은 배열의 길이이거나 객체의 키 개수일 수 있다.
*/

// ex)
function sum(arr) {
    let total = 0;
    for (let i = 0; i < arr.length; i++) {
        total += arr[i];
    }
    return total;
}
// 위의 코드에서 공간을 차지 할 것들은? : total이라는 변수, 반복문 안에 i 이렇게 2개가 있다.
// total 변수를 보면 반복 시 시간은 걸려도, 공간은 늘어나지 않는다. 그렇기 때문에 배열의 크기와는 상관없이 n이 커져도
// 1000이어도 100만일 수도 있다. 즉, 새로운 변수를 만들지 않는다.
// 결국 상수 공간이 있다는 것인다. 그 공간은 O(1) 공간이다. (입력의 크기와 상관없이 똑같다.)

// ex2)
function double(arr) {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        newArr.push(2 * arr[i]);
    }
    return newArr;
}
// 위의 코드에서 반복되면서 배열의 크기가 늘어나서 무한대에 가까워질수록 공간 복잡도가 어떻게 된느지?
// newArr 변수는 차지 하는 공간은 입력 된 배열의 크기와 비례해서 커진다. 그래서 O(n) 공간을 차지하게 된다.
// newArr를 n+1 이나 n+2 를 쓰는 대신에 최대한 단순하게 O(n)으로 단순화할 수 있다.

// 연습 문제 : 아래 함수에 대한 공간 복잡도 구하기
function subtotals(array) {
    var subtotalArray = Array(array.length);
    for (var i = 0; i < array.length; i++) {
        var subtotal = 0;
        for (var j = 0; j <= i; j++){
            subtotal += array[j];
        }
        subtotalArray[i] = subtotal;
    }
    return subtotalArray;
} // 답은 : O(n)


/* 
    11강: 로그와 섹션 요약
    이 개념을 짚고 넘어가는 이유 : 어떤 알고리즘들은 O(1), O(n), O(n제곱) 처럼 간단하지 않은 경우가 있다.
    Big O 표기들 중에 더 어렵거나 덜 흔한 수학 개념들이 포함되어 있을 수 있다. 그 중 자주 나오는 개념이 로그이다.
    예를들면 해당 알고리즘의 Big O가 O(n)인 대신에 O(log n)일 수 있다.

    - 알고리즘 성능을 분석하기 위해서는 빅오 표기법을 사용한다.
    1) 입력의 크기가 늘어날수록 전체적인 추세와 관련되어 있다.
    2) 실행 시간이 어떻게 변하는지 아니면 공간 복잡도가 어떻게 변하는지 이다.
    3) 정확도가 아니라 전체적인 추세를 중요하게 생각한다.
    4) 빅오로 측정되는 알고리즘의 시간과 공단 복잡도는 하드웨어에 영향을 받지 않는다.
    5) 빅오는 실행될 연산의 갯수를 따진다. 내 컴퓨터에서 10 밀리초가 걸리고, 다른 컴퓨터에서는 1 밀리초가 걸리는 차이는 중요하지 않다.
    6) 빅오표기법은 세상 모든 곳에서 사용된다.

    학습 후 지진강도를 비교하듯이 이제 알고리즘들을 서로 비교할 수 있을 것이다. "이건 좋고, 이건 나쁘다." 라고 말하면서 그리고
    "공간 복잡도가 어떻고 시간 복잡도가 어떻다" 라고 설명할 수 있게 된 것이다.
    < 나머지 내용은 패드에 정리 ... >
*/