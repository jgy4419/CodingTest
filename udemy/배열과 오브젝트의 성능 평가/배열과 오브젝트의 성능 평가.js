/* 
    빅오 표기법, 시간과 공간 복잡성, 코드 성능 분석에 대해 배운 내용을 토대로 적용
    - 배열, 오브젝트, 내장된 메서드와 루프들의 성능을 얼마나 좋은가요?
    - 배열로 가장 쉽고 빠르게 할 수 있는 것은 무엇인지?
    - 생각보다 느린 메서드는 무엇인지?
    
    해당 강의는 빅오의 시점에서 오브젝트와 배열이 어떻게 작동하는지 보기
    - 배열에 데이터를 입력하는데 빠른 방법이 있고 느린 방법이 있는지?
    - 왜 배열 앞에 데이터를 추가하는 것이 좋지 않은지?
    - 더 좋음 방법이 있는지 대안을 보고 배열을 처리하는 시간을 비교하기 
*/

/* 
    Object (BigO와 성능을 보는 관점에서 보기)

    언제 Object를 사용하는가?
    - 객체는 정렬되어 있을 필요가 없을때 잘 작동한다.
    - 빠른 접근, 입력과 제거를 원할 때 좋다. 
    - 빠르다고 했을 때 입력, 제거, 접근하는 시간이 상수 시간이라는 것이다.
        Insertion: O(1)
        Removal: O(1)
        Searching: O(N)
        Access: O(1)
    자바스크립트가 어떤 정보를 객체 안에 상수 시간안에 저장할 수 있다는 것이다.
    그리고 기본적인 연산은 매우 빠르게 한다 정렬 되어있지 않다.

    객체에 따라오는 메서드들
    - Object.keys: O(N)
    - Object.values: O(N)
    - Object.entries: O(N)
    - hasOwnProperty: O(1)
    keys, values, entries는 만약 element가 100개 이거나, 속성이 100개라면 처리해야할 연산이 100개가 있다는 것이다.
    hasOwnProperty는 firstName이라는 속성을 전달하면 해당 속성이 있는지 없는지만 알려준다.

    정리하면 객체는 모든것을 빠르게 처리하지만, 정렬되어 있지는 않다. 배열이 더 빠를 수도 있지만 작업에 따라 느릴 수 있다.
    정리하면 객체는 어떠한 상황에도 작동할 것이고, key value가 모두 있고 모든 연산, 입력, 접근, 업데이트, 제거 이 모두 상수 시간이다.
    탐색은 희귀하지만, O(N)은 N에 따라서 자라니 선형 시간이다.
*/
// ex) 오브젝트
let instructor = {
    firstName: 'Kelly',
    isInstructor: true,
    favoriteNumbers: [1, 2, 3, 4];
}

/* 
    배열 안의 데이터에 접근이 느린 이유 (배열을 빅오를 통해서 판단해보고 객체와 비교했을 때 성능이 어떤지 봐보기)
    - 배열에 가장 중요한 점은 정렬되어 있다는 점이다. (데이터가 정렬되어 있는 기준이 있다.) 한 뭉치로 있는 객체와는 다르다.
    - 정렬되어 있는 것이 필요하다면 유용하지만, 연산을 하는 시간이 더 걸릴 수도 있다.
    - 배열은 대부분 정렬되어 있는 데이터를 위해서 사용한다.

    선형 리스트 구조
    - 정렬되어 있는 것이 필요하더라도, 싱글 링크 리스트와 더블 링크 리스트처럼 코드안에 정렬된 구조가 있는 데이터도 있다.
    - 엘리먼트마다 특정한 위치에 있고 순서대로 연결되어 있다.
    - 정렬되어 있는 데이터가 필요할 때 배열을 사용할 수 있지만, 성능을 희색해야 할 수도 있다. (특히 입력과 제거를 할 때)

    Big O of Arrays
    - Insertion: It depends...
    - Removal: It depends...
    - Searching: O(N)
    - Access: O(1) (객체와 동일하다)

    Access
    ex) element가 10000개가 있는 배열이 있고 9000번째 엘리먼트를 요청했을때 자바스크립트는 모든 엘리먼트를 하나씩 지나가면서
        9000번까지 숫자를 세고 있다가 9000번째 element에 도착해서 반환해주는 것이 아니다. 쉽게 지름길이 있다 생각하면 된다.

    - 숫자가 있고, 인덱스가 있고, 배열안에 존재하는 인덱스 등 이러한 것들이 조건이다. (실제로 있는 인덱스인지?)
        바로 해당 데이터로 갈 수 있다. 그래서 배열이 얼마나 긴지는 중요하지 않다. 
    
    Insert : 어디에 입력되는지에 따라 다르다.
    - 끝에다 배열을 push하면 이 작업은 O(1)으로 상수시간이다. (객체 추가하는 것과 다른 게 없다.)
    - 문제는 배열 앞에 추가할 때이다. 문제가 되는 이유는 인덱스들 때문인데, 앞쪽에 추가하면 인덱스들을 모두 새로 배정해야 된다. (배열이 클수록 더 오래걸림)
    - 그렇기 때문에 배열 앞에 추가를 한다면 O(N) 선형 시간이다.
    - 그래서 배열 앞에 추가하거나 제거하는것은 최대한 피해야된다.
    - 앞에 추가하는 작업이 의미가 있을 때는

    배열이 비어있을 때 제외하면 push와 pop하는 작업이 shift와 unshift 작업보다 빠르다.
*/

/* 
    빅오 배열 메서드
    - push: O(1)
    - pop: O(1)
    - shift: O(N)
    - unshift: O(N)
    - concat: O(N)
    - slice: O(N)
    - splice: O(N)
    - sort: O(N * log N)
    - forEach/map/reducer/etc.: O(N) // element 마다 한 작업식 수행한다. 그러니 배열이 커질수록 걸리는 시간도 늘어난다.

    sort는 당장은 O(N)보다 더 크가는 것만 알면된다. 
    - 비교하고, element를 이동시키고, 정렬하려면 element들을 한번씩 보는것만으로 충분하지 않다.
*/
// ex)
let names = ["Michael", "Melissa", "Andrea"];
let values = [true, {}, [], 2, "awesome"];

/* 
    잔체정리
    - 객체는 거의 모든것을 더 빠르게 하지만, 정렬되어 있지 않다.
    - 배열은 정렬되어 있지만, 끝에 추가하고 제거하는 작업이 시작에 추가하고 제거하는 작업보다 훨씬 빠르다는 것이다.
     
*/